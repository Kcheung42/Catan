{"version":3,"sources":["catan_board/utils/board_generator.cljs"],"mappings":";AASA;;;kDAAA,0DAAAA,5GAAMG;AAAN,AAAA,IAAAF,aAAAD;QAAA,AAAAE,4CAAAD,WAAA,IAAA,/DAEIG;QAFJ,AAAAF,4CAAAD,WAAA,IAAA,/DAEMI;AAFN,AAAA,0FAAA,uGAAA,uGAAA,uGAAA,uGAAA,+GAAA,xbAGI,KAAA,JAAKD,SAAGC,6FACR,KAAA,JAAKD,SAAGC,6FACRD,EAAE,KAAA,JAAKC,oGACPD,EAAE,KAAA,JAAKC,oGACP,KAAA,JAAKD,SAAG,KAAA,JAAKC,oGACb,KAAA,JAAKD,SAAG,KAAA,JAAKC;;AAEjB;;;oEAAA,pEAAMC,gJAEHC;AAFH,AAGE,IAAMC,YAAU,+CAAA,WAAAC,1DAACC;AAAD,AAAS,OAACC,+CAAuB,AAAA,uFAAAF;GAAaF;IACxDK,aAAW,AAACC,cAAI,4CAAA,5CAACC,oGAAWN;AADlC,AAEE,OAACO,eAAK,WAAKC;AAAL,AACE,IAAMC,YAAU,AAACd,gDAAc,AAAA,sFAAQa;IACjCE,kBAAgB,AAACL,cAAII;AAD3B,AAEE,OAACE,cAAI,AAACC,uDAAyBR,WAAWM;GAC9CV;;AAIV;;;qDAAA,rDAAMa,kHAEHC;AAFH,AAGE,IAAMC,gBAAc,AAACC;AAArB,AACE,OAACC,6CAAK,WAAKC,MAAMC;AAAX,AAAA,kDAAA,8DAAA,qEAAA,yDAAA,pIACUD,kEACGC;GAEbL,OACAC;;AAEV;;;mDAAA,nDAAMK,8GAEHrB;AAFH,AAGE,IAAMsB,cAAY,AAACC;IACbC,cAAY,AAACC,6CAAKH;AADxB,AAEE,OAACJ,6CAAK,WAAKT;AAAL,AACE,GAAI,6CAAA,7CAACiB,sGAAU,AAAA,0FAAWjB;AACxBA;;AACA,IAAMkB,MAAI,gBAAA,AAAAC,hBAACC,gCAAOL;AAAlB,AACE,AAACM,mDAAMN,YAAYO;;AACnB,yDAAA,lDAACC,8CAAMvB,6DAAYkB;;GACzB3B;;AAEV;;;;mDAAA,nDAAMiC,8GAGHC;AAHH,AAIE,IAAMnB,SAAO,AAACoB;IACRC,uBAAqB,AAACtB,mDAAiBC;IACvCsB,UAAQ,AAACC;AAFf,AAGE,eAAA,XAAOC;mBAAP,fACOC;;AADP,AAEE,GAAI,CAAID,YAASC;AAEf,IAAMxC,QAAM,AAACqB,iDAAee;AAA5B,AAAA,kDAAA,8DAAA,mEAAA,6DAAA,2CAAA,gGAAA,mIAAA,kGAAA,tfACUpC,iEACEqC,qLACgB,AAAc,KAAAI,oFAClB,4CAAK,AAACC,oGACCR,oFACPK;;AAExB,IAAMvC,QAAM,AAACqB,iDAAee;AAA5B,AACE,GAAI,EAAI,AAACO,cAAIT,6BACL,AAACS,cAAI,AAAC5C,kEAA0BC;AADxC,kDAAA,8DAAA,mEAAA,6DAAA,2CAAA,gGAAA,mIAAA,kGAAA,tfAGUA,iEACEqC,qLACgB,AAAc,KAAAI,oFAClB,4CAAK,AAACC,oGACCR,oFACP,YAAA,XAAKK;;AAE3B,eAAO,YAAA,XAAKA;eAAUC","names":["p__14239","vec__14240","cljs.core.nth","catan-board.utils.board-generator/hex-neighbors","q","r","catan-board.utils.board-generator/has-adjacent-red-numbers?","hexes","red-hexes","p1__14243#","cljs.core.filter","catan-board.utils.numbers/is-red-number?","red-coords","cljs.core/set","cljs.core.map","cljs.core/some","hex","neighbors","neighbor-coords","cljs.core/seq","clojure.set.intersection","catan-board.utils.board-generator/assign-resources","coords","resource-deck","catan-board.utils.resources/create-resource-deck","cljs.core.mapv","coord","resource","catan-board.utils.board-generator/assign-numbers","number-deck","catan-board.utils.numbers/create-number-deck","number-atom","cljs.core.atom","cljs.core._EQ_","num","cljs.core/deref","cljs.core/first","cljs.core.swap_BANG_","cljs.core/rest","cljs.core.assoc","catan-board.utils.board-generator/generate-board","tournament-mode?","catan-board.utils.hex/generate-catan-grid","hexes-with-resources","harbors","catan-board.utils.harbors/assign-harbors","attempts","max-attempts","js/Date","cljs.core/random-uuid","cljs.core/not"],"sourcesContent":["(ns catan-board.utils.board-generator\n  (:require\n   [catan-board.utils.hex :as hex]\n   [catan-board.utils.resources :as resources]\n   [catan-board.utils.numbers :as numbers]\n   [catan-board.utils.harbors :as harbors]))\n\n;; -- Board Validation --------------------------------------------------------\n\n(defn hex-neighbors\n  \"Returns the axial coordinates of all neighbors of a hex at [q r]\"\n  [[q r]]\n  [[(inc q) r]\n   [(dec q) r]\n   [q (inc r)]\n   [q (dec r)]\n   [(inc q) (dec r)]\n   [(dec q) (inc r)]])\n\n(defn has-adjacent-red-numbers?\n  \"Checks if any two hexes with red numbers (6 or 8) are adjacent\"\n  [hexes]\n  (let [red-hexes (filter #(numbers/is-red-number? (:number %)) hexes)\n        red-coords (set (map :coord red-hexes))]\n    (some (fn [hex]\n            (let [neighbors (hex-neighbors (:coord hex))\n                  neighbor-coords (set neighbors)]\n              (seq (clojure.set/intersection red-coords neighbor-coords))))\n          red-hexes)))\n\n;; -- Board Generation --------------------------------------------------------\n\n(defn assign-resources\n  \"Assigns resources to hex coordinates randomly\"\n  [coords]\n  (let [resource-deck (resources/create-resource-deck)]\n    (mapv (fn [coord resource]\n            {:coord coord\n             :resource resource\n             :number nil})\n          coords\n          resource-deck)))\n\n(defn assign-numbers\n  \"Assigns numbers to hexes (skipping desert)\"\n  [hexes]\n  (let [number-deck (numbers/create-number-deck)\n        number-atom (atom number-deck)]\n    (mapv (fn [hex]\n            (if (= :desert (:resource hex))\n              hex\n              (let [num (first @number-atom)]\n                (swap! number-atom rest)\n                (assoc hex :number num))))\n          hexes)))\n\n(defn generate-board\n  \"Generates a complete Catan board with random resource and number placement.\n   If tournament-mode? is true, ensures no adjacent red numbers (6 & 8)\"\n  [tournament-mode?]\n  (let [coords (hex/generate-catan-grid)\n        hexes-with-resources (assign-resources coords)\n        harbors (harbors/assign-harbors)]\n    (loop [attempts 0\n           max-attempts 100]\n      (if (>= attempts max-attempts)\n        ;; Fallback after max attempts - just return whatever we have\n        (let [hexes (assign-numbers hexes-with-resources)]\n          {:hexes hexes\n           :harbors harbors\n           :metadata {:generated-at (.toISOString (js/Date.))\n                      :board-id (str (random-uuid))\n                      :tournament-mode tournament-mode?\n                      :attempts attempts}})\n        ;; Try generating board\n        (let [hexes (assign-numbers hexes-with-resources)]\n          (if (or (not tournament-mode?)\n                  (not (has-adjacent-red-numbers? hexes)))\n            ;; Valid board - return it\n            {:hexes hexes\n             :harbors harbors\n             :metadata {:generated-at (.toISOString (js/Date.))\n                        :board-id (str (random-uuid))\n                        :tournament-mode tournament-mode?\n                        :attempts (inc attempts)}}\n            ;; Invalid - try again\n            (recur (inc attempts) max-attempts)))))))\n"]}